--- a/config/Config-build.in
+++ b/config/Config-build.in
@@ -76,6 +76,7 @@
 
 	config BUILD_PATENTED
 		bool "Compile with support for patented functionality"
+		default y
 		help
 		  When this option is disabled, software which provides patented functionality
 		  will not be built.  In case software provides optional support for patented

--- a/config/Config-images.in
+++ b/config/Config-images.in
@@ -89,7 +89,7 @@
 
 	menuconfig TARGET_ROOTFS_EXT4FS
 		bool "ext4"
-		default y if USES_EXT4
+		default n
 		help
 		  Build an ext4 root filesystem.
 
@@ -242,7 +242,7 @@
 	config GRUB_TIMEOUT
 		string "Seconds to wait before booting the default entry"
 		depends on GRUB_IMAGES || GRUB_EFI_IMAGES
-		default "5"
+		default "0"
 		help
 		  If you don't know, 5 seconds is a reasonable default.
 

--- a/include/version.mk
+++ b/include/version.mk
@@ -29,7 +29,7 @@
 VERSION_CODE:=$(if $(VERSION_CODE),$(VERSION_CODE),$(REVISION))
 
 VERSION_REPO:=$(call qstrip,$(CONFIG_VERSION_REPO))
-VERSION_REPO:=$(if $(VERSION_REPO),$(VERSION_REPO),https://downloads.openwrt.org/snapshots)
+VERSION_REPO:=$(if $(VERSION_REPO),$(VERSION_REPO),https://mirrors.tencent.com/openwrt/snapshots)
 
 VERSION_DIST:=$(call qstrip,$(CONFIG_VERSION_DIST))
 VERSION_DIST:=$(if $(VERSION_DIST),$(VERSION_DIST),OpenWrt)

--- a/package/base-files/files/bin/config_generate
+++ b/package/base-files/files/bin/config_generate
@@ -162,8 +162,8 @@
		static)
			local ipad
			case "$1" in
-				lan) ipad=${ipaddr:-"192.168.1.1"} ;;
-				*) ipad=${ipaddr:-"192.168.$((addr_offset++)).1"} ;;
+				lan) ipad=${ipaddr:-"10.0.0.1"} ;;
+				*) ipad=${ipaddr:-"10.0.$((addr_offset++)).1"} ;;
			esac

			netm=${netmask:-"255.255.255.0"}
@@ -177,18 +177,7 @@
 		;;
 
 		dhcp)
-			# fixup IPv6 slave interface if parent is a bridge
-			[ "$type" = "bridge" ] && device="br-$1"
-
 			uci set network.$1.proto='dhcp'
-			[ -e /proc/sys/net/ipv6 ] && {
-				uci -q batch <<-EOF
-					delete network.${1}6
-					set network.${1}6='interface'
-					set network.${1}6.device='$device'
-					set network.${1}6.proto='dhcpv6'
-				EOF
-			}
 		;;
 
 		pppoe)
@@ -196,16 +185,8 @@
 				set network.$1.proto='pppoe'
 				set network.$1.username='username'
 				set network.$1.password='password'
+				set network.$1.ipv6='auto'
 			EOF
-			[ -e /proc/sys/net/ipv6 ] && {
-				uci -q batch <<-EOF
-					set network.$1.ipv6='1'
-					delete network.${1}6
-					set network.${1}6='interface'
-					set network.${1}6.device='@${1}'
-					set network.${1}6.proto='dhcpv6'
-				EOF
-			}
 		;;
 
 		ncm|\
@@ -312,7 +293,8 @@
 		delete system.@system[0]
 		add system system
 		set system.@system[-1].hostname='OpenWrt'
-		set system.@system[-1].timezone='UTC'
+		set system.@system[-1].zonename='Asia/Hong Kong'
+		set system.@system[-1].timezone='HKT-8'
 		set system.@system[-1].ttylogin='0'
 		set system.@system[-1].log_size='64'
 		set system.@system[-1].urandom_seed='0'
@@ -320,11 +302,9 @@
 		delete system.ntp
 		set system.ntp='timeserver'
 		set system.ntp.enabled='1'
-		set system.ntp.enable_server='0'
-		add_list system.ntp.server='0.openwrt.pool.ntp.org'
-		add_list system.ntp.server='1.openwrt.pool.ntp.org'
-		add_list system.ntp.server='2.openwrt.pool.ntp.org'
-		add_list system.ntp.server='3.openwrt.pool.ntp.org'
+		set system.ntp.enable_server='1'
+		add_list system.ntp.server='ntp1.aliyun.com'
+		add_list system.ntp.server='time2.cloud.tencent.com'
 	EOF
 
 	if json_is_a system object; then

--- a/package/base-files/files/etc/board.d/99-default_network
+++ b/package/base-files/files/etc/board.d/99-default_network
@@ -8,8 +8,15 @@
 
 json_is_a network object && exit 0
 
-ucidef_set_interface_lan 'eth0'
-[ -d /sys/class/net/eth1 ] && ucidef_set_interface_wan 'eth1'
+A=$(ls /sys/class/net | grep -c eth)
+if [ $A -gt 1 ];then
+	let A=A-1
+	ucidef_set_interface_wan eth0
+	for i in $(seq 1 $A);do B="$B eth$i";done
+	ucidef_set_interface_lan "${B#* }"
+else
+	ucidef_set_interface_lan eth0
+fi
 
 board_config_flush
 

--- a/package/base-files/image-config.in
+++ b/package/base-files/image-config.in
@@ -190,7 +190,7 @@
 	config VERSION_REPO
 		string
 		prompt "Release repository"
-		default "https://downloads.openwrt.org/snapshots"
+		default "https://mirrors.tencent.com/openwrt/snapshots"
 		help
 			This is the repository address embedded in the image, it defaults
 			to the trunk snapshot repo; the url may contain the following placeholders:

--- a/package/network/services/dnsmasq/files/dhcp.conf
+++ b/package/network/services/dnsmasq/files/dhcp.conf
@@ -1,37 +1,25 @@
 config dnsmasq
-	option domainneeded	1
-	option boguspriv	1
-	option filterwin2k	0  # enable for dial on demand
-	option localise_queries	1
-	option rebind_protection 1  # disable if upstream must serve RFC1918 addresses
-	option rebind_localhost 1  # enable for RBL checking and similar services
-	#list rebind_domain example.lan  # whitelist RFC1918 responses for domains
-	option local	'/lan/'
-	option domain	'lan'
-	option expandhosts	1
-	option nonegcache	0
-	option cachesize	1000
-	option authoritative	1
-	option readethers	1
-	option leasefile	'/tmp/dhcp.leases'
-	option resolvfile	'/tmp/resolv.conf.d/resolv.conf.auto'
-	#list server		'/mycompany.local/1.2.3.4'
-	option nonwildcard	1 # bind to & keep track of interfaces
-	#list interface		br-lan
-	#list notinterface	lo
-	#list bogusnxdomain     '64.94.110.11'
-	option localservice	1  # disable to allow DNS requests from non-local subnets
-	option ednspacket_max	1232
-	option filter_aaaa	0
-	option filter_a		0
-	#list addnmount		/some/path # read-only mount path to expose it to dnsmasq
+	option domainneeded '1'
+	option authoritative '1'
+	option local '/lan/'
+	option domain 'lan'
+	option rebind_protection '1'
+	option rebind_localhost '1'
+	option localservice '0'
+	option nonwildcard '0'
+	option readethers '1'
+	option leasefile '/tmp/dhcp.leases'
+	option sequential_ip '1'
+	option localise_queries '1'
+	option expandhosts '1'
+	option ednspacket_max '1232'
+	option cachesize '1000'
+	option filter_aaaa '0'
+	option filter_a '0'
 
-config dhcp lan
-	option interface	lan
-	option start 	100
-	option limit	150
-	option leasetime	12h
-
-config dhcp wan
-	option interface	wan
-	option ignore	1
+config dhcp 'lan'
+	option interface 'lan'
+	option start '10'
+	option limit '150'
+	option leasetime '2h'
+	option force '1'

--- a/package/network/services/odhcpd/files/odhcpd.defaults
+++ b/package/network/services/odhcpd/files/odhcpd.defaults
@@ -11,41 +11,20 @@
 json_select ..
 json_select ..
 
-ODHCPDONLY=0
-V4MODE=disabled
-V6MODE=disabled
-
-[ -e /usr/sbin/dnsmasq ] || ODHCPDONLY=1
-
 case "$protocol" in
 # only enable server mode on statically addressed lan ports
-"static")
-	V4MODE=server
-	[ -e /proc/sys/net/ipv6 ] && V6MODE=server
-	;;
+"static") [ -e /proc/sys/net/ipv6 ] && MODE=server || MODE=disabled ;;
+*) MODE=disabled ;;
 esac
 
-uci get dhcp.lan 1>/dev/null 2>/dev/null || {
-uci batch <<EOF
-set dhcp.lan=dhcp
-set dhcp.lan.interface='lan'
-set dhcp.lan.start='100'
-set dhcp.lan.limit='150'
-set dhcp.lan.leasetime='12h'
-set dhcp.lan.domain='lan'
-EOF
-}
-
 uci batch <<EOF
 set dhcp.odhcpd=odhcpd
-set dhcp.odhcpd.maindhcp=$ODHCPDONLY
+set dhcp.odhcpd.maindhcp=0
 set dhcp.odhcpd.leasefile=/tmp/hosts/odhcpd
 set dhcp.odhcpd.leasetrigger=/usr/sbin/odhcpd-update
 set dhcp.odhcpd.loglevel=4
-set dhcp.lan.dhcpv4=$V4MODE
-set dhcp.lan.dhcpv6=$V6MODE
-set dhcp.lan.ra=$V6MODE
-set dhcp.lan.ra_slaac=1
+set dhcp.lan.ra=$MODE
+set dhcp.lan.dhcpv6=$MODE
 add_list dhcp.lan.ra_flags=managed-config
 add_list dhcp.lan.ra_flags=other-config
 commit dhcp

--- a/package/network/services/uhttpd/files/uhttpd.config
+++ b/package/network/services/uhttpd/files/uhttpd.config
@@ -1,151 +1,31 @@
-# Server configuration
-config uhttpd main
 
-	# HTTP listen addresses, multiple allowed
-	list listen_http	0.0.0.0:80
-	list listen_http	[::]:80
-
-	# HTTPS listen addresses, multiple allowed
-	list listen_https	0.0.0.0:443
-	list listen_https	[::]:443
-
-	# Redirect HTTP requests to HTTPS if possible
-	option redirect_https	0
-
-	# Server document root
-	option home		/www
-
-	# Reject requests from RFC1918 IP addresses
-	# directed to the servers public IP(s).
-	# This is a DNS rebinding countermeasure.
-	option rfc1918_filter 1
-
-	# Maximum number of concurrent requests.
-	# If this number is exceeded, further requests are
-	# queued until the number of running requests drops
-	# below the limit again.
-	option max_requests 3
-
-	# Maximum number of concurrent connections.
-	# If this number is exceeded, further TCP connection
-	# attempts are queued until the number of active
-	# connections drops below the limit again.
-	option max_connections 100
-
-	# Certificate and private key for HTTPS.
-	# If no listen_https addresses are given,
-	# the key options are ignored.
-	option cert		/etc/uhttpd.crt
-	option key		/etc/uhttpd.key
-
-	# CGI url prefix, will be searched in docroot.
-	# Default is /cgi-bin
-	option cgi_prefix	/cgi-bin
-
-	# List of extension->interpreter mappings.
-	# Files with an associated interpreter can
-	# be called outside of the CGI prefix and do
-	# not need to be executable.
-#	list interpreter	".php=/usr/bin/php-cgi"
-#	list interpreter	".cgi=/usr/bin/perl"
-
-	# List of prefix->Lua handler mappings.
-	# Any request to an URL beneath the prefix
-	# will be dispatched to the associated Lua
-	# handler script. Lua support is disabled when
-	# no handler mappings are specified. Lua prefix
-	# matches have precedence over the CGI prefix.
-	list lua_prefix		"/cgi-bin/luci=/usr/lib/lua/luci/sgi/uhttpd.lua"
-
-	# List of prefix->ucode handler mappings.
-	# Any request to an URL beneath the prefix
-	# will be dispatched to the associated ucode
-	# handler script. Ucode support is disabled when
-	# no handler mappings are specified. Ucode prefix
-	# matches have precedence over the CGI prefix.
-#	list ucode_prefix		"/ucode/example=/usr/share/example.uc"
-
-	# Specify the ubus-rpc prefix and socket path.
-#	option ubus_prefix	/ubus
-#	option ubus_socket	/var/run/ubus/ubus.sock
-
-	# CGI/Lua timeout, if the called script does not
-	# write data within the given amount of seconds,
-	# the server will terminate the request with
-	# 504 Gateway Timeout response.
-	option script_timeout	60
-
-	# Network timeout, if the current connection is
-	# blocked for the specified amount of seconds,
-	# the server will terminate the associated
-	# request process.
-	option network_timeout	30
-
-	# HTTP Keep-Alive, specifies the timeout for persistent
-	# HTTP/1.1 connections. Setting this to 0 will disable
-	# persistent HTTP connections.
-	option http_keepalive	20
-
-	# TCP Keep-Alive, send periodic keep-alive probes
-	# over established connections to detect dead peers.
-	# The value is given in seconds to specify the
-	# interval between subsequent probes.
-	# Setting this to 0 will disable TCP keep-alive.
-	option tcp_keepalive	1
-
-	# Basic auth realm, defaults to local hostname
-#	option realm	OpenWrt
-
-	# Configuration file in busybox httpd format
-#	option config	/etc/httpd.conf
-
-	# Do not follow symlinks that point outside of the
-	# home directory.
-#	option no_symlinks	0
-
-	# Do not produce directory listings but send 403
-	# instead if a client requests an url pointing to
-	# a directory without any index file.
-#	option no_dirlists	0
-
-	# Do not authenticate any ubus-rpc requests against
-	# the ubus session/access procedure.
-	# This is dangerous and should be always left off
-	# except for development and debug purposes!
-#	option no_ubusauth	0
-
-	# For this instance of uhttpd use the listed httpauth
-	# sections to require Basic auth to the specified
-	# resources.
-#	list httpauth prefix_user
-
-
-# Defaults for automatic certificate and key generation
-config cert defaults
-
-	# Validity time
-	option days		730
-
-	# key type: rsa or ec
-	option key_type		ec
-
-	# RSA key size
-	option bits		2048
-
-	# EC curve name
-	# Curve names vary between px5g-{wolfssl,mbedtls} and openssl
-	# P-256 or P-384 are guaranteed to work
-	option ec_curve		P-256
-
-	# Location
-	option country		ZZ
-	option state		Somewhere
-	option location		Unknown
-
-	# Common name
-	option commonname	'%D'
-
-# config httpauth prefix_user
-#	option prefix /protected/url/path
-#	option username user
-#	option password 'plaintext_or_md5_or_$p$user_for_system_user'
+config uhttpd 'main'
+	list listen_http '0.0.0.0:80'
+	list listen_http '[::]:80'
+	list listen_https '0.0.0.0:443'
+	list listen_https '[::]:443'
+	option redirect_https '0'
+	option home '/www'
+	option rfc1918_filter '1'
+	option max_requests '3'
+	option max_connections '100'
+	option cert '/etc/uhttpd.crt'
+	option key '/etc/uhttpd.key'
+	option cgi_prefix '/cgi-bin'
+	list lua_prefix '/cgi-bin/luci=/usr/lib/lua/luci/sgi/uhttpd.lua'
+	option script_timeout '60'
+	option network_timeout '30'
+	option http_keepalive '20'
+	option tcp_keepalive '1'
+	option ubus_prefix '/ubus'
+
+config cert 'defaults'
+	option days '730'
+	option key_type 'ec'
+	option bits '2048'
+	option ec_curve 'P-256'
+	option country 'ZZ'
+	option state 'Somewhere'
+	option location 'Unknown'
+	option commonname '%D'
+ 

--- a/package/utils/busybox/config/networking/Config.in
+++ b/package/utils/busybox/config/networking/Config.in
@@ -807,5 +807,19 @@
 	default BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_LONG_OPTIONS
 	depends on BUSYBOX_CONFIG_FEATURE_NSLOOKUP_BIG && BUSYBOX_CONFIG_LONG_OPTS
+config BUSYBOX_CONFIG_NSLOOKUP_OPENWRT
+	bool "nslookup_openwrt"
+	depends on !BUSYBOX_CONFIG_NSLOOKUP
+	default BUSYBOX_DEFAULT_NSLOOKUP_OPENWRT
+	help
+	  nslookup is a tool to query Internet name servers (LEDE flavor).
+
+config BUSYBOX_CONFIG_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+       bool "Enable long options"
+       default BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+       depends on BUSYBOX_CONFIG_NSLOOKUP_OPENWRT && BUSYBOX_CONFIG_LONG_OPTS
+       help
+         Support long options for the nslookup applet.
+
 config BUSYBOX_CONFIG_NTPD
 	bool "ntpd (22 kb)"
 	default BUSYBOX_DEFAULT_NTPD

--- /dev/null
+++ b/package/utils/busybox/patches/230-add.patch
@@ -0,0 +1,971 @@
+From ab0f8bb80527928f513297ab93e3ec8c8b48dd50 Mon Sep 17 00:00:00 2001
+From: Jo-Philipp Wich <jo@mein.io>
+Date: Tue, 14 Mar 2017 22:21:34 +0100
+Subject: [PATCH] networking: add LEDE nslookup applet
+
+Add a new LEDE nslookup applet which is compatible with musl libc
+and providing more features like ability to specify query type.
+
+In contrast to busybox' builtin nslookup applet, this variant does
+not rely on libc resolver internals but uses explicit send logic
+and the libresolv primitives to parse received DNS responses.
+
+Signed-off-by: Jo-Philipp Wich <jo@mein.io>
+---
+ Makefile.flags             |   6 +
+ networking/nslookup_lede.c | 915 +++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 921 insertions(+)
+ create mode 100644 networking/nslookup_lede.c
+
+--- a/Makefile.flags
++++ b/Makefile.flags
+@@ -158,6 +158,12 @@ endif
+ # libm may be needed for dc, awk, ntpd
+ # librt may be needed for clock_gettime()
+ 
++# nslookup_lede might need the resolv library
++RESOLV_AVAILABLE := $(shell echo 'int main(void){res_init();return 0;}' >resolvtest.c; $(CC) $(CFLAGS) -include resolv.h -lresolv -o /dev/null resolvtest.c >/dev/null 2>&1 && echo "y"; rm resolvtest.c)
++ifeq ($(RESOLV_AVAILABLE),y)
++LDLIBS += resolv
++endif
++
+ # libpam may use libpthread, libdl and/or libaudit.
+ # On some platforms that requires an explicit -lpthread, -ldl, -laudit.
+ # However, on *other platforms* it fails when some of those flags
+--- /dev/null
++++ b/networking/nslookup_lede.c
+@@ -0,0 +1,934 @@
++/*
++ * nslookup_lede - musl compatible replacement for busybox nslookup
++ *
++ * Copyright (C) 2017 Jo-Philipp Wich <jo@mein.io>
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++//config:config NSLOOKUP_OPENWRT
++//config:	bool "nslookup_openwrt"
++//config:	depends on !NSLOOKUP
++//config:	default y
++//config:	help
++//config:	  nslookup is a tool to query Internet name servers (LEDE flavor).
++//config:
++//config:config FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
++//config:       bool "Enable long options"
++//config:       default y
++//config:       depends on NSLOOKUP_OPENWRT && LONG_OPTS
++//config:       help
++//config:         Support long options for the nslookup applet.
++
++//applet:IF_NSLOOKUP_OPENWRT(APPLET(nslookup, BB_DIR_USR_BIN, BB_SUID_DROP))
++
++//kbuild:lib-$(CONFIG_NSLOOKUP_OPENWRT) += nslookup_lede.o
++
++//usage:#define nslookup_lede_trivial_usage
++//usage:       "[HOST] [SERVER]"
++//usage:#define nslookup_lede_full_usage "\n\n"
++//usage:       "Query the nameserver for the IP address of the given HOST\n"
++//usage:       "optionally using a specified DNS server"
++//usage:
++//usage:#define nslookup_lede_example_usage
++//usage:       "$ nslookup localhost\n"
++//usage:       "Server:     default\n"
++//usage:       "Address:    default\n"
++//usage:       "\n"
++//usage:       "Name:       debian\n"
++//usage:       "Address:    127.0.0.1\n"
++
++#include <stdio.h>
++#include <resolv.h>
++#include <string.h>
++#include <errno.h>
++#include <time.h>
++#include <poll.h>
++#include <unistd.h>
++#include <stdlib.h>
++#include <sys/socket.h>
++#include <arpa/inet.h>
++#include <net/if.h>
++#include <netdb.h>
++
++#include "libbb.h"
++
++struct ns {
++	const char *name;
++	len_and_sockaddr addr;
++	int failures;
++	int replies;
++};
++
++struct query {
++	const char *name;
++	size_t qlen, rlen;
++	unsigned char query[512], reply[512];
++	unsigned long latency;
++	int rcode, n_ns;
++};
++
++static struct {
++	int type;
++	const char *name;
++} qtypes[] = {
++	{ ns_t_soa,   "SOA"   },
++	{ ns_t_ns,    "NS"    },
++	{ ns_t_a,     "A"     },
++#if ENABLE_FEATURE_IPV6
++	{ ns_t_aaaa,  "AAAA"  },
++#endif
++	{ ns_t_cname, "CNAME" },
++	{ ns_t_mx,    "MX"    },
++	{ ns_t_txt,   "TXT"   },
++	{ ns_t_srv,   "SRV"   },
++	{ ns_t_ptr,   "PTR"   },
++	{ ns_t_any,   "ANY"   },
++	{ }
++};
++
++static const char *rcodes[] = {
++	"NOERROR",
++	"FORMERR",
++	"SERVFAIL",
++	"NXDOMAIN",
++	"NOTIMP",
++	"REFUSED",
++	"YXDOMAIN",
++	"YXRRSET",
++	"NXRRSET",
++	"NOTAUTH",
++	"NOTZONE",
++	"RESERVED11",
++	"RESERVED12",
++	"RESERVED13",
++	"RESERVED14",
++	"RESERVED15",
++	"BADVERS"
++};
++
++static unsigned int default_port = 53;
++static unsigned int default_retry = 2;
++static unsigned int default_timeout = 5;
++
++
++static int parse_reply(const unsigned char *msg, size_t len, int *bb_style_counter)
++{
++	ns_msg handle;
++	ns_rr rr;
++	int i, n, rdlen;
++	const char *format = NULL;
++	char astr[INET6_ADDRSTRLEN], dname[MAXDNAME];
++	const unsigned char *cp;
++
++	if (ns_initparse(msg, len, &handle) != 0) {
++		//fprintf(stderr, "Unable to parse reply: %s\n", strerror(errno));
++		return -1;
++	}
++
++	for (i = 0; i < ns_msg_count(handle, ns_s_an); i++) {
++		if (ns_parserr(&handle, ns_s_an, i, &rr) != 0) {
++			//fprintf(stderr, "Unable to parse resource record: %s\n", strerror(errno));
++			return -1;
++		}
++
++		if (bb_style_counter && *bb_style_counter == 1)
++			printf("Name:      %s\n", ns_rr_name(rr));
++
++		rdlen = ns_rr_rdlen(rr);
++
++		switch (ns_rr_type(rr))
++		{
++		case ns_t_a:
++			if (rdlen != 4) {
++				//fprintf(stderr, "Unexpected A record length\n");
++				return -1;
++			}
++			inet_ntop(AF_INET, ns_rr_rdata(rr), astr, sizeof(astr));
++			if (bb_style_counter)
++				printf("Address %d: %s\n", (*bb_style_counter)++, astr);
++			else
++				printf("Name:\t%s\nAddress: %s\n", ns_rr_name(rr), astr);
++			break;
++
++#if ENABLE_FEATURE_IPV6
++		case ns_t_aaaa:
++			if (rdlen != 16) {
++				//fprintf(stderr, "Unexpected AAAA record length\n");
++				return -1;
++			}
++			inet_ntop(AF_INET6, ns_rr_rdata(rr), astr, sizeof(astr));
++			if (bb_style_counter)
++				printf("Address %d: %s\n", (*bb_style_counter)++, astr);
++			else
++				printf("%s\thas AAAA address %s\n", ns_rr_name(rr), astr);
++			break;
++#endif
++
++		case ns_t_ns:
++			if (!format)
++				format = "%s\tnameserver = %s\n";
++			/* fall through */
++
++		case ns_t_cname:
++			if (!format)
++				format = "%s\tcanonical name = %s\n";
++			/* fall through */
++
++		case ns_t_ptr:
++			if (!format)
++				format = "%s\tname = %s\n";
++			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++				ns_rr_rdata(rr), dname, sizeof(dname)) < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++			printf(format, ns_rr_name(rr), dname);
++			break;
++
++		case ns_t_mx:
++			if (rdlen < 2) {
++				fprintf(stderr, "MX record too short\n");
++				return -1;
++			}
++			n = ns_get16(ns_rr_rdata(rr));
++			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++				ns_rr_rdata(rr) + 2, dname, sizeof(dname)) < 0) {
++				//fprintf(stderr, "Cannot uncompress MX domain: %s\n", strerror(errno));
++				return -1;
++			}
++			printf("%s\tmail exchanger = %d %s\n", ns_rr_name(rr), n, dname);
++			break;
++
++		case ns_t_txt:
++			if (rdlen < 1) {
++				//fprintf(stderr, "TXT record too short\n");
++				return -1;
++			}
++			n = *(unsigned char *)ns_rr_rdata(rr);
++			if (n > 0) {
++				memset(dname, 0, sizeof(dname));
++				memcpy(dname, ns_rr_rdata(rr) + 1, n);
++				printf("%s\ttext = \"%s\"\n", ns_rr_name(rr), dname);
++			}
++			break;
++
++		case ns_t_srv:
++			if (rdlen < 6) {
++				//printf("SRV record too short\n");
++				return -1;
++			}
++
++			cp = ns_rr_rdata(rr);
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp + 6, dname, sizeof(dname));
++
++			if (n < 0) {
++				//printf("Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("%s\tservice = %hu %hu %hu %s\n", ns_rr_name(rr),
++				ns_get16(cp), ns_get16(cp + 2), ns_get16(cp + 4), dname);
++			break;
++
++		case ns_t_soa:
++			if (rdlen < 20) {
++				//fprintf(stderr, "SOA record too short\n");
++				return -1;
++			}
++
++			printf("%s\n", ns_rr_name(rr));
++
++			cp = ns_rr_rdata(rr);
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp, dname, sizeof(dname));
++
++			if (n < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("\torigin = %s\n", dname);
++			cp += n;
++
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp, dname, sizeof(dname));
++
++			if (n < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("\tmail addr = %s\n", dname);
++			cp += n;
++
++			printf("\tserial = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\trefresh = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\tretry = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\texpire = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\tminimum = %lu\n", ns_get32(cp));
++			break;
++
++		default:
++			break;
++		}
++	}
++
++	return i;
++}
++
++static int parse_nsaddr(const char *addrstr, len_and_sockaddr *lsa)
++{
++	char *eptr, *hash, ifname[IFNAMSIZ];
++	unsigned int port = default_port;
++	unsigned int scope = 0;
++
++	hash = strchr(addrstr, '#');
++
++	if (hash) {
++		*hash++ = '\0';
++		port = strtoul(hash, &eptr, 10);
++
++		if (eptr == hash || *eptr != '\0' || port > 65535) {
++			errno = EINVAL;
++			return -1;
++		}
++	}
++
++	hash = strchr(addrstr, '%');
++
++	if (hash) {
++		for (eptr = ++hash; *eptr != '\0' && *eptr != '#'; eptr++) {
++			if ((eptr - hash) >= IFNAMSIZ) {
++				errno = ENODEV;
++				return -1;
++			}
++
++			ifname[eptr - hash] = *eptr;
++		}
++
++		ifname[eptr - hash] = '\0';
++		scope = if_nametoindex(ifname);
++
++		if (scope == 0) {
++			errno = ENODEV;
++			return -1;
++		}
++	}
++
++#if ENABLE_FEATURE_IPV6
++	if (inet_pton(AF_INET6, addrstr, &lsa->u.sin6.sin6_addr)) {
++		lsa->u.sin6.sin6_family = AF_INET6;
++		lsa->u.sin6.sin6_port = htons(port);
++		lsa->u.sin6.sin6_scope_id = scope;
++		lsa->len = sizeof(lsa->u.sin6);
++		return 0;
++	}
++#endif
++
++	if (!scope && inet_pton(AF_INET, addrstr, &lsa->u.sin.sin_addr)) {
++		lsa->u.sin.sin_family = AF_INET;
++		lsa->u.sin.sin_port = htons(port);
++		lsa->len = sizeof(lsa->u.sin);
++		return 0;
++	}
++
++	errno = EINVAL;
++	return -1;
++}
++
++static char *make_ptr(const char *addrstr)
++{
++	const char *hexdigit = "0123456789abcdef";
++	static char ptrstr[73];
++	unsigned char addr[16];
++	char *ptr = ptrstr;
++	int i;
++
++	if (inet_pton(AF_INET6, addrstr, addr)) {
++		if (memcmp(addr, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12) != 0) {
++			for (i = 0; i < 16; i++) {
++				*ptr++ = hexdigit[(unsigned char)addr[15 - i] & 0xf];
++				*ptr++ = '.';
++				*ptr++ = hexdigit[(unsigned char)addr[15 - i] >> 4];
++				*ptr++ = '.';
++			}
++			strcpy(ptr, "ip6.arpa");
++		}
++		else {
++			sprintf(ptr, "%u.%u.%u.%u.in-addr.arpa",
++			        addr[15], addr[14], addr[13], addr[12]);
++		}
++
++		return ptrstr;
++	}
++
++	if (inet_pton(AF_INET, addrstr, addr)) {
++		sprintf(ptr, "%u.%u.%u.%u.in-addr.arpa",
++		        addr[3], addr[2], addr[1], addr[0]);
++		return ptrstr;
++	}
++
++	return NULL;
++}
++
++static unsigned long mtime(void)
++{
++	struct timespec ts;
++	clock_gettime(CLOCK_REALTIME, &ts);
++	return (unsigned long)ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
++}
++
++#if ENABLE_FEATURE_IPV6
++static void to_v4_mapped(len_and_sockaddr *a)
++{
++	if (a->u.sa.sa_family != AF_INET)
++		return;
++
++	memcpy(a->u.sin6.sin6_addr.s6_addr + 12,
++	       &a->u.sin.sin_addr, 4);
++
++	memcpy(a->u.sin6.sin6_addr.s6_addr,
++	       "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
++
++	a->u.sin6.sin6_family = AF_INET6;
++	a->u.sin6.sin6_flowinfo = 0;
++	a->u.sin6.sin6_scope_id = 0;
++	a->len = sizeof(a->u.sin6);
++}
++#endif
++
++
++/*
++ * Function logic borrowed & modified from musl libc, res_msend.c
++ */
++
++static int send_queries(struct ns *ns, int n_ns, struct query *queries, int n_queries)
++{
++	int fd;
++	int timeout = default_timeout * 1000, retry_interval, servfail_retry = 0;
++	len_and_sockaddr from = { };
++#if ENABLE_FEATURE_IPV6
++	int one = 1;
++#endif
++	int recvlen = 0;
++	int n_replies = 0;
++	struct pollfd pfd;
++	unsigned long t0, t1, t2;
++	int nn, qn, next_query = 0;
++
++	from.u.sa.sa_family = AF_INET;
++	from.len = sizeof(from.u.sin);
++
++#if ENABLE_FEATURE_IPV6
++	for (nn = 0; nn < n_ns; nn++) {
++		if (ns[nn].addr.u.sa.sa_family == AF_INET6) {
++			from.u.sa.sa_family = AF_INET6;
++			from.len = sizeof(from.u.sin6);
++			break;
++		}
++	}
++#endif
++
++	/* Get local address and open/bind a socket */
++	fd = socket(from.u.sa.sa_family, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
++
++#if ENABLE_FEATURE_IPV6
++	/* Handle case where system lacks IPv6 support */
++	if (fd < 0 && from.u.sa.sa_family == AF_INET6 && errno == EAFNOSUPPORT) {
++		fd = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
++		from.u.sa.sa_family = AF_INET;
++	}
++#endif
++
++	if (fd < 0)
++		return -1;
++
++	if (bind(fd, &from.u.sa, from.len) < 0) {
++		close(fd);
++		return -1;
++	}
++
++#if ENABLE_FEATURE_IPV6
++	/* Convert any IPv4 addresses in a mixed environment to v4-mapped */
++	if (from.u.sa.sa_family == AF_INET6) {
++		setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one));
++
++		for (nn = 0; nn < n_ns; nn++)
++			to_v4_mapped(&ns[nn].addr);
++	}
++#endif
++
++	pfd.fd = fd;
++	pfd.events = POLLIN;
++	retry_interval = timeout / default_retry;
++	t0 = t2 = mtime();
++	t1 = t2 - retry_interval;
++
++	for (; t2 - t0 < timeout; t2 = mtime()) {
++		if (t2 - t1 >= retry_interval) {
++			for (qn = 0; qn < n_queries; qn++) {
++				if (queries[qn].rlen)
++					continue;
++
++				for (nn = 0; nn < n_ns; nn++) {
++					sendto(fd, queries[qn].query, queries[qn].qlen,
++					       MSG_NOSIGNAL, &ns[nn].addr.u.sa, ns[nn].addr.len);
++				}
++			}
++
++			t1 = t2;
++			servfail_retry = 2 * n_queries;
++		}
++
++		/* Wait for a response, or until time to retry */
++		if (poll(&pfd, 1, t1+retry_interval-t2) <= 0)
++			continue;
++
++		while (1) {
++			recvlen = recvfrom(fd, queries[next_query].reply,
++			                   sizeof(queries[next_query].reply), 0,
++			                   &from.u.sa, &from.len);
++
++			/* read error */
++			if (recvlen < 0)
++				break;
++
++			/* Ignore non-identifiable packets */
++			if (recvlen < 4)
++				continue;
++
++			/* Ignore replies from addresses we didn't send to */
++			for (nn = 0; nn < n_ns; nn++)
++				if (memcmp(&from.u.sa, &ns[nn].addr.u.sa, from.len) == 0)
++					break;
++
++			if (nn >= n_ns)
++				continue;
++
++			/* Find which query this answer goes with, if any */
++			for (qn = next_query; qn < n_queries; qn++)
++				if (!memcmp(queries[next_query].reply, queries[qn].query, 2))
++					break;
++
++			if (qn >= n_queries || queries[qn].rlen)
++				continue;
++
++			queries[qn].rcode = queries[next_query].reply[3] & 15;
++			queries[qn].latency = mtime() - t0;
++			queries[qn].n_ns = nn;
++
++			ns[nn].replies++;
++
++			/* Only accept positive or negative responses;
++			 * retry immediately on server failure, and ignore
++			 * all other codes such as refusal. */
++			switch (queries[qn].rcode) {
++			case 0:
++			case 3:
++				break;
++
++			case 2:
++				if (servfail_retry && servfail_retry--) {
++					ns[nn].failures++;
++					sendto(fd, queries[qn].query, queries[qn].qlen,
++					       MSG_NOSIGNAL, &ns[nn].addr.u.sa, ns[nn].addr.len);
++				}
++				/* fall through */
++
++			default:
++				continue;
++			}
++
++			/* Store answer */
++			n_replies++;
++
++			queries[qn].rlen = recvlen;
++
++			if (qn == next_query) {
++				while (next_query < n_queries) {
++					if (!queries[next_query].rlen)
++						break;
++
++					next_query++;
++				}
++			}
++			else {
++				memcpy(queries[qn].reply, queries[next_query].reply, recvlen);
++			}
++
++			if (next_query >= n_queries)
++				return n_replies;
++		}
++	}
++
++	return n_replies;
++}
++
++static struct ns *add_ns(struct ns **ns, int *n_ns, const char *addr)
++{
++	char portstr[sizeof("65535")], *p;
++	len_and_sockaddr a = { };
++	struct ns *tmp;
++	struct addrinfo *ai, *aip, hints = {
++		.ai_flags = AI_NUMERICSERV,
++		.ai_socktype = SOCK_DGRAM
++	};
++
++	if (parse_nsaddr(addr, &a)) {
++		/* Maybe we got a domain name, attempt to resolve it using the standard
++		 * resolver routines */
++
++		p = strchr(addr, '#');
++		snprintf(portstr, sizeof(portstr), "%hu",
++		         (unsigned short)(p ? strtoul(p, NULL, 10) : default_port));
++
++		if (!getaddrinfo(addr, portstr, &hints, &ai)) {
++			for (aip = ai; aip; aip = aip->ai_next) {
++				if (aip->ai_addr->sa_family != AF_INET &&
++				    aip->ai_addr->sa_family != AF_INET6)
++					continue;
++
++#if ! ENABLE_FEATURE_IPV6
++				if (aip->ai_addr->sa_family != AF_INET)
++					continue;
++#endif
++
++				tmp = realloc(*ns, sizeof(**ns) * (*n_ns + 1));
++
++				if (!tmp)
++					return NULL;
++
++				*ns = tmp;
++
++				(*ns)[*n_ns].name = addr;
++				(*ns)[*n_ns].replies = 0;
++				(*ns)[*n_ns].failures = 0;
++				(*ns)[*n_ns].addr.len = aip->ai_addrlen;
++
++				memcpy(&(*ns)[*n_ns].addr.u.sa, aip->ai_addr, aip->ai_addrlen);
++
++				(*n_ns)++;
++			}
++
++			freeaddrinfo(ai);
++
++			return &(*ns)[*n_ns];
++		}
++
++		return NULL;
++	}
++
++	tmp = realloc(*ns, sizeof(**ns) * (*n_ns + 1));
++
++	if (!tmp)
++		return NULL;
++
++	*ns = tmp;
++
++	(*ns)[*n_ns].addr = a;
++	(*ns)[*n_ns].name = addr;
++	(*ns)[*n_ns].replies = 0;
++	(*ns)[*n_ns].failures = 0;
++
++	return &(*ns)[(*n_ns)++];
++}
++
++static int parse_resolvconf(struct ns **ns, int *n_ns)
++{
++	int prev_n_ns = *n_ns;
++	char line[128], *p;
++	FILE *resolv;
++
++	if ((resolv = fopen("/etc/resolv.conf", "r")) != NULL) {
++		while (fgets(line, sizeof(line), resolv)) {
++			p = strtok(line, " \t\n");
++
++			if (!p || strcmp(p, "nameserver"))
++				continue;
++
++			p = strtok(NULL, " \t\n");
++
++			if (!p)
++				continue;
++
++			if (!add_ns(ns, n_ns, strdup(p))) {
++				free(p);
++				break;
++			}
++		}
++
++		fclose(resolv);
++	}
++
++	return *n_ns - prev_n_ns;
++}
++
++static struct query *add_query(struct query **queries, int *n_queries,
++                               int type, const char *dname)
++{
++	struct query *tmp;
++	ssize_t qlen;
++
++	tmp = realloc(*queries, sizeof(**queries) * (*n_queries + 1));
++
++	if (!tmp)
++		return NULL;
++
++	memset(&tmp[*n_queries], 0, sizeof(*tmp));
++
++	qlen = res_mkquery(QUERY, dname, C_IN, type, NULL, 0, NULL,
++	                   tmp[*n_queries].query, sizeof(tmp[*n_queries].query));
++
++	tmp[*n_queries].qlen = qlen;
++	tmp[*n_queries].name = dname;
++	*queries = tmp;
++
++	return &tmp[(*n_queries)++];
++}
++
++static char *sal2str(len_and_sockaddr *a)
++{
++	static char buf[INET6_ADDRSTRLEN + 1 + IFNAMSIZ + 1 + 5 + 1];
++	char *p = buf;
++
++#if ENABLE_FEATURE_IPV6
++	if (a->u.sa.sa_family == AF_INET6) {
++		inet_ntop(AF_INET6, &a->u.sin6.sin6_addr, buf, sizeof(buf));
++		p += strlen(p);
++
++		if (a->u.sin6.sin6_scope_id) {
++			if (if_indextoname(a->u.sin6.sin6_scope_id, p + 1)) {
++				*p++ = '%';
++				p += strlen(p);
++			}
++		}
++	}
++	else
++#endif
++	{
++		inet_ntop(AF_INET, &a->u.sin.sin_addr, buf, sizeof(buf));
++		p += strlen(p);
++	}
++
++	sprintf(p, "#%hu", ntohs(a->u.sin.sin_port));
++
++	return buf;
++}
++
++int nslookup_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
++int nslookup_main(int argc, char **argv)
++{
++	int rc = 1;
++	char *ptr, *chr;
++	struct ns *ns = NULL;
++	struct query *queries = NULL;
++	llist_t *type_strings = NULL;
++	int n_ns = 0, n_queries = 0;
++	int c, opts, option_index = 0;
++	int stats = 0, bb_style_counter = 0;
++	unsigned int types = 0;
++	HEADER *header;
++
++#if ENABLE_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
++	static const char nslookup_longopts[] ALIGN1 =
++		"type\0"		Required_argument	"q"
++		"querytype\0"		Required_argument	"q"
++		"port\0"		Required_argument	"p"
++		"retry\0"		Required_argument	"r"
++		"timeout\0"		Required_argument	"t"
++		"stats\0"		No_argument		"s"
++	;
++
++	opts = getopt32long(argv, "^" "+q:*p:+r:+t:+s" "\0" "q::",
++			nslookup_longopts,
++	                &type_strings, &default_port,
++	                &default_retry, &default_timeout);
++#else
++	opts = getopt32(argv, "^" "+q:*p:+r:+t:+s" "\0" "q::",
++	                &type_strings, &default_port,
++	                &default_retry, &default_timeout);
++#endif
++
++	while (type_strings) {
++		ptr = llist_pop(&type_strings);
++
++		/* skip leading text, e.g. when invoked with -querytype=AAAA */
++		if ((chr = strchr(ptr, '=')) != NULL)
++			ptr = chr + 1;
++
++		for (c = 0; qtypes[c].name; c++)
++			if (!strcmp(qtypes[c].name, ptr))
++				break;
++
++		if (!qtypes[c].name) {
++			fprintf(stderr, "Invalid query type \"%s\"\n", ptr);
++			goto out;
++		}
++
++		types |= (1 << c);
++	}
++
++	if (default_port > 65535) {
++		fprintf(stderr, "Invalid server port\n");
++		goto out;
++	}
++
++	if (!default_retry) {
++		fprintf(stderr, "Invalid retry value\n");
++		goto out;
++	}
++
++	if (!default_timeout) {
++		fprintf(stderr, "Invalid timeout value\n");
++		goto out;
++	}
++
++	stats = (opts & 16);
++
++	if (optind >= argc)
++		bb_show_usage();
++
++	for (option_index = optind;
++	     option_index < ((argc - optind) > 1 ? argc - 1 : argc);
++	     option_index++) {
++
++		/* No explicit type given, guess query type.
++		 * If we can convert the domain argument into a ptr (means that
++		 * inet_pton() could read it) we assume a PTR request, else
++		 * we issue A+AAAA queries and switch to an output format
++		 * mimicking the one of the traditional nslookup applet. */
++		if (types == 0) {
++			ptr = make_ptr(argv[option_index]);
++
++			if (ptr) {
++				add_query(&queries, &n_queries, T_PTR, ptr);
++			}
++			else {
++				bb_style_counter = 1;
++				add_query(&queries, &n_queries, T_A, argv[option_index]);
++#if ENABLE_FEATURE_IPV6
++				add_query(&queries, &n_queries, T_AAAA, argv[option_index]);
++#endif
++			}
++		}
++		else {
++			for (c = 0; qtypes[c].name; c++)
++				if (types & (1 << c))
++					add_query(&queries, &n_queries, qtypes[c].type,
++					          argv[option_index]);
++		}
++	}
++
++	/* Use given DNS server if present */
++	if (option_index < argc) {
++		if (!add_ns(&ns, &n_ns, argv[option_index])) {
++			fprintf(stderr, "Invalid NS server address \"%s\": %s\n",
++			        argv[option_index], strerror(errno));
++			goto out;
++		}
++	}
++	else {
++		parse_resolvconf(&ns, &n_ns);
++	}
++
++	/* Fall back to localhost if we could not find NS in resolv.conf */
++	if (n_ns == 0) {
++		add_ns(&ns, &n_ns, "127.0.0.1");
++	}
++
++	for (c = 0; c < n_ns; c++) {
++		rc = send_queries(&ns[c], 1, queries, n_queries);
++
++		if (rc < 0) {
++			fprintf(stderr, "Failed to send queries: %s\n", strerror(errno));
++			goto out;
++		} else if (rc > 0) {
++			break;
++		}
++	}
++
++	if (c >= n_ns) {
++		fprintf(stderr,
++			    ";; connection timed out; no servers could be reached\n\n");
++
++		return 1;
++	}
++
++	printf("Server:\t\t%s\n", ns[c].name);
++	printf("Address:\t%s\n", sal2str(&ns[c].addr));
++
++	if (stats) {
++		printf("Replies:\t%d\n", ns[c].replies);
++		printf("Failures:\t%d\n", ns[c].failures);
++	}
++
++	printf("\n");
++
++	for (rc = 0; rc < n_queries; rc++) {
++		if (stats) {
++			printf("Query #%d completed in %lums:\n", rc, queries[rc].latency);
++		}
++
++		if (queries[rc].rcode != 0) {
++			printf("** server can't find %s: %s\n", queries[rc].name,
++			       rcodes[queries[rc].rcode]);
++			continue;
++		}
++
++		c = 0;
++
++		if (queries[rc].rlen) {
++			if (!bb_style_counter) {
++				header = (HEADER *)queries[rc].reply;
++
++				if (!header->aa)
++					printf("Non-authoritative answer:\n");
++
++				c = parse_reply(queries[rc].reply, queries[rc].rlen, NULL);
++			}
++			else {
++				c = parse_reply(queries[rc].reply, queries[rc].rlen,
++				                &bb_style_counter);
++			}
++		}
++
++		if (c == 0)
++			printf("*** Can't find %s: No answer\n", queries[rc].name);
++		else if (c < 0)
++			printf("*** Can't find %s: Parse error\n", queries[rc].name);
++
++		if (!bb_style_counter)
++			printf("\n");
++	}
++
++	rc = 0;
++
++out:
++	if (n_ns)
++		free(ns);
++
++	if (n_queries)
++		free(queries);
++
++	return rc;
++}

--- a/package/utils/busybox/Config-defaults.in
+++ b/package/utils/busybox/Config-defaults.in
@@ -2525,13 +2525,19 @@
 	default y
 config BUSYBOX_DEFAULT_NSLOOKUP
 	bool
-	default y
+	default n
 config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_BIG
 	bool
-	default y
+	default n
 config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_LONG_OPTIONS
 	bool
 	default n
+config BUSYBOX_DEFAULT_NSLOOKUP_OPENWRT
+	bool
+	default y
+config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+	bool
+	default n
 config BUSYBOX_DEFAULT_NTPD
 	bool
 	default y

--- a/package/utils/busybox/Makefile
+++ b/package/utils/busybox/Makefile
@@ -97,7 +97,7 @@
 LDLIBS += $(call BUSYBOX_IF_ENABLED,PAM,pam pam_misc pthread)
 
 ifeq ($(CONFIG_USE_GLIBC),y)
-  LDLIBS += $(call BUSYBOX_IF_ENABLED,NSLOOKUP,resolv)
+  LDLIBS += $(call BUSYBOX_IF_ENABLED,NSLOOKUP_OPENWRT,resolv)
 endif
 
 ifeq ($(BUILD_VARIANT),selinux)

--- /dev/null
+++ b/tools/ucl/Makefile
@@ -0,0 +1,51 @@
+#
+# Copyright (C) 2019 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=ucl
+PKG_VERSION:=1.03
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_SOURCE_URL:=http://www.oberhumer.com/opensource/ucl/download/$(PKG_SOURCE)
+PKG_HASH:=b865299ffd45d73412293369c9754b07637680e5c826915f097577cd27350348
+
+HOST_BUILD_DIR:=$(BUILD_DIR_HOST)/$(PKG_NAME)-$(PKG_VERSION)
+
+include $(INCLUDE_DIR)/host-build.mk
+
+HOSTCC :=gcc
+HOST_CFLAGS +=-std=gnu89
+
+define Host/Prepare
+	$(Host/Prepare/Default)
+	mkdir -p $(STAGING_DIR_HOST)/include/ucl
+endef
+
+define Host/Configure
+	(cd $(HOST_BUILD_DIR); \
+	CC="$(HOSTCC)" \
+	CFLAGS="$(HOST_CFLAGS)" \
+	./configure --prefix=$(STAGING_DIR_HOST) \
+	);
+	$(call Host/Configure/Default)
+endef
+
+define Host/Compile
+	$(MAKE) -C $(HOST_BUILD_DIR)
+endef
+
+define Host/Install
+	$(MAKE) -C $(HOST_BUILD_DIR) install
+endef
+
+define Host/Clean
+	$(MAKE) -C $(HOST_BUILD_DIR) uninstall
+	rm -rf $(HOST_BUILD_DIR)
+	rm -rf $(STAGING_DIR_HOST)/include/ucl
+endef
+
+$(eval $(call HostBuild))

--- /dev/null
+++ b/tools/upx/Makefile
@@ -0,0 +1,66 @@
+#
+# Copyright (C) 2011-2022 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=upx
+PKG_RELEASE:=1
+
+PKG_MAINTAINER:=Xingwang Liao <kuoruan@gmail.com>
+PKG_LICENSE:=GPL-2.0-only
+PKG_LICENSE_FILES:=COPYING LICENSE
+
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_DATE:=2023-01-30
+PKG_SOURCE_VERSION:=33cdcb0e8277576cc64894bb332c469942864bcd
+PKG_SOURCE_URL:=https://github.com/upx/upx.git
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_SOURCE_DATE).tar.gz
+
+HOST_BUILD_DEPENDS:=ucl/host
+
+include $(INCLUDE_DIR)/host-build.mk
+include $(INCLUDE_DIR)/package.mk
+
+define Host/Compile
+	UPX_UCLDIR=$(STAGING_DIR_HOST) \
+	$(MAKE) -C $(HOST_BUILD_DIR)/src \
+		CXXFLAGS_WERROR="" LDFLAGS="$(HOST_LDFLAGS)" \
+		CXX="$(HOSTCXX)"
+endef
+
+define Host/Install
+	$(CP) $(HOST_BUILD_DIR)/src/upx.out $(STAGING_DIR_HOST)/bin/upx
+endef
+
+define Host/Clean
+	rm -f $(STAGING_DIR_HOST)/bin/upx
+endef
+
+define Package/upx
+  SECTION:=utils
+  CATEGORY:=Utilities
+  DEPENDS:=+libucl +libstdcpp +zlib
+  TITLE:=The Ultimate Packer for eXecutables
+  URL:=https://upx.github.io/
+endef
+
+define Package/upx/description
+UPX is a free, portable, extendable, high-performance executable packer for
+several different executable formats. It achieves an excellent compression ratio
+and offers very fast decompression. Your executables suffer no memory overhead
+or other drawbacks for most of the formats supported, because of in-place
+decompression.
+endef
+
+MAKE_PATH := src
+
+define Package/upx/install
+	$(INSTALL_DIR) $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_BUILD_DIR)/src/upx.out $(1)/usr/bin/upx
+endef
+
+$(eval $(call HostBuild))
+$(eval $(call BuildPackage,upx))

--- a/tools/Makefile
+++ b/tools/Makefile
@@ -68,6 +68,7 @@
 tools-y += zip
 tools-y += zlib
 tools-y += zstd
+tools-y += ucl upx
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS),y) += liblzo
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_B43_TOOLS),y) += b43-tools
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_BZIP2_TOOLS),y) += bzip2
@@ -85,6 +86,7 @@
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(CONFIG_USE_LLVM_BUILD),y) += llvm-bpf
 
 # builddir dependencies
+$(curdir)/upx/compile := $(curdir)/ucl/compile
 $(curdir)/autoconf/compile := $(curdir)/m4/compile
 $(curdir)/automake/compile := $(curdir)/autoconf/compile $(curdir)/pkgconf/compile $(curdir)/xz/compile
 $(curdir)/b43-tools/compile := $(curdir)/bison/compile

--- /dev/null
+++ b/package/network/config/netifd/patches/001-fix.patch
@@ -0,0 +1,136 @@
+--- a/device.c
++++ b/device.c
+@@ -61,8 +61,6 @@
+ 	[DEV_ATTR_DROP_UNSOLICITED_NA] = { .name = "drop_unsolicited_na", .type = BLOBMSG_TYPE_BOOL },
+ 	[DEV_ATTR_ARP_ACCEPT] = { .name = "arp_accept", .type = BLOBMSG_TYPE_BOOL },
+ 	[DEV_ATTR_AUTH] = { .name = "auth", .type = BLOBMSG_TYPE_BOOL },
+-	[DEV_ATTR_SPEED] = { .name = "speed", .type = BLOBMSG_TYPE_INT32 },
+-	[DEV_ATTR_DUPLEX] = { .name = "duplex", .type = BLOBMSG_TYPE_BOOL },
+ };
+ 
+ const struct uci_blob_param_list device_attr_list = {
+@@ -278,8 +276,6 @@
+ 	n->arp_accept = s->flags & DEV_OPT_ARP_ACCEPT ?
+ 		s->arp_accept : os->arp_accept;
+ 	n->auth = s->flags & DEV_OPT_AUTH ? s->auth : os->auth;
+-	n->speed = s->flags & DEV_OPT_SPEED ? s->speed : os->speed;
+-	n->duplex = s->flags & DEV_OPT_DUPLEX ? s->duplex : os->duplex;
+ 	n->flags = s->flags | os->flags | os->valid_flags;
+ }
+ 
+@@ -454,16 +450,6 @@
+ 		s->flags |= DEV_OPT_AUTH;
+ 	}
+ 
+-	if ((cur = tb[DEV_ATTR_SPEED])) {
+-		s->speed = blobmsg_get_u32(cur);
+-		s->flags |= DEV_OPT_SPEED;
+-	}
+-
+-	if ((cur = tb[DEV_ATTR_DUPLEX])) {
+-		s->duplex = blobmsg_get_bool(cur);
+-		s->flags |= DEV_OPT_DUPLEX;
+-	}
+-
+ 	device_set_disabled(dev, disabled);
+ }
+ 
+
+--- a/device.h
++++ b/device.h
+@@ -60,8 +60,6 @@
+ 	DEV_ATTR_DROP_UNSOLICITED_NA,
+ 	DEV_ATTR_ARP_ACCEPT,
+ 	DEV_ATTR_AUTH,
+-	DEV_ATTR_SPEED,
+-	DEV_ATTR_DUPLEX,
+ 	__DEV_ATTR_MAX,
+ };
+ 
+@@ -124,8 +122,6 @@
+ 	DEV_OPT_DROP_GRATUITOUS_ARP	= (1ULL << 27),
+ 	DEV_OPT_DROP_UNSOLICITED_NA	= (1ULL << 28),
+ 	DEV_OPT_ARP_ACCEPT		= (1ULL << 29),
+-	DEV_OPT_SPEED			= (1ULL << 30),
+-	DEV_OPT_DUPLEX			= (1ULL << 31),
+ };
+ 
+ /* events broadcasted to all users of a device */
+@@ -201,8 +197,6 @@
+ 	bool drop_unsolicited_na;
+ 	bool arp_accept;
+ 	bool auth;
+-	unsigned int speed;
+-	bool duplex;
+ };
+ 
+ /*
+
+--- a/system-linux.c
++++ b/system-linux.c
+@@ -1691,57 +1691,6 @@
+ 	return system_link_del(vlandev->ifname);
+ }
+ 
+-static void
+-system_set_ethtool_settings(struct device *dev, struct device_settings *s)
+-{
+-	struct ethtool_cmd ecmd = {
+-		.cmd = ETHTOOL_GSET,
+-	};
+-	struct ifreq ifr = {
+-		.ifr_data = (caddr_t)&ecmd,
+-	};
+-	static const struct {
+-		unsigned int speed;
+-		uint8_t bit_half;
+-		uint8_t bit_full;
+-	} speed_mask[] = {
+-		{ 10, ETHTOOL_LINK_MODE_10baseT_Half_BIT, ETHTOOL_LINK_MODE_10baseT_Full_BIT },
+-		{ 100, ETHTOOL_LINK_MODE_100baseT_Half_BIT, ETHTOOL_LINK_MODE_100baseT_Full_BIT },
+-		{ 1000, ETHTOOL_LINK_MODE_1000baseT_Half_BIT, ETHTOOL_LINK_MODE_1000baseT_Full_BIT },
+-	};
+-	uint32_t adv;
+-	size_t i;
+-
+-	strncpy(ifr.ifr_name, dev->ifname, sizeof(ifr.ifr_name) - 1);
+-
+-	if (ioctl(sock_ioctl, SIOCETHTOOL, &ifr) != 0)
+-		return;
+-
+-	adv = ecmd.supported;
+-	for (i = 0; i < ARRAY_SIZE(speed_mask); i++) {
+-		if (s->flags & DEV_OPT_DUPLEX) {
+-			int bit = s->duplex ? speed_mask[i].bit_half : speed_mask[i].bit_full;
+-			adv &= ~(1 << bit);
+-		}
+-
+-		if (!(s->flags & DEV_OPT_SPEED) ||
+-		    s->speed == speed_mask[i].speed)
+-			continue;
+-
+-		adv &= ~(1 << speed_mask[i].bit_full);
+-		adv &= ~(1 << speed_mask[i].bit_half);
+-	}
+-
+-
+-	if (ecmd.autoneg && ecmd.advertising == adv)
+-		return;
+-
+-	ecmd.autoneg = 1;
+-	ecmd.advertising = adv;
+-	ecmd.cmd = ETHTOOL_SSET;
+-	ioctl(sock_ioctl, SIOCETHTOOL, &ifr);
+-}
+-
+ void
+ system_if_get_settings(struct device *dev, struct device_settings *s)
+ {
+@@ -1965,7 +1914,6 @@
+ 		system_set_drop_unsolicited_na(dev, s->drop_unsolicited_na ? "1" : "0");
+ 	if (apply_mask & DEV_OPT_ARP_ACCEPT)
+ 		system_set_arp_accept(dev, s->arp_accept ? "1" : "0");
+-	system_set_ethtool_settings(dev, s);
+ }
+ 
+ int system_if_up(struct device *dev)

--- a/include/target.mk
+++ b/include/target.mk
@@ -33,16 +33,6 @@
 DEFAULT_PACKAGES+=busybox procd
 endif
 
-# include ujail on systems with enough storage
-ifeq ($(CONFIG_SMALL_FLASH),)
-DEFAULT_PACKAGES+=procd-ujail
-endif
-
-# include seccomp ld-preload hooks if kernel supports it
-ifneq ($(CONFIG_SECCOMP),)
-DEFAULT_PACKAGES+=procd-seccomp
-endif
-
 # For the basic set
 DEFAULT_PACKAGES.basic:=
 # For nas targets
 
--- /dev/null
+++ b/package/network/config/firewall4/patches/999-01-firewall4-add-fullcone-support.patch
@@ -0,0 +1,459 @@
+From aa3b56e289fba7425e649a608c333622ffd9c367 Mon Sep 17 00:00:00 2001
+From: Syrone Wong <wong.syrone@gmail.com>
+Date: Sat, 9 Apr 2022 13:24:19 +0800
+Subject: [PATCH] firewall4: add fullcone support
+
+fullcone is drop-in replacement of masq for non-udp traffic
+
+add runtime fullcone rule check, disable it globally if fullcone expr is
+invalid
+
+defaults.fullcone is the global switch, while zone.fullcone4 and
+zone.fullcone6 are switches for IPv4 and IPv6 respectively, most
+IPv6 traffic do NOT need this FullCone NAT functionality.
+---
+ root/usr/share/firewall4/templates/ruleset.uc | 11 ++++-
+ .../firewall4/templates/zone-fullcone.uc      |  4 ++
+ root/usr/share/ucode/fw4.uc                   | 44 ++++++++++++++++++-
+ 4 files changed, 58 insertions(+), 3 deletions(-)
+ create mode 100644 root/usr/share/firewall4/templates/zone-fullcone.uc
+
+--- a/root/etc/config/firewall
++++ b/root/etc/config/firewall
+@@ -1,189 +1,48 @@
+-config defaults
+-	option syn_flood	1
+-	option input		REJECT
+-	option output		ACCEPT
+-	option forward		REJECT
+-# Uncomment this line to disable ipv6 rules
+-#	option disable_ipv6	1
+-
+-config zone
+-	option name		lan
+-	list   network		'lan'
+-	option input		ACCEPT
+-	option output		ACCEPT
+-	option forward		ACCEPT
+-
+-config zone
+-	option name		wan
+-	list   network		'wan'
+-	list   network		'wan6'
+-	option input		REJECT
+-	option output		ACCEPT
+-	option forward		REJECT
+-	option masq		1
+-	option mtu_fix		1
+-
+-config forwarding
+-	option src		lan
+-	option dest		wan
+-
+-# We need to accept udp packets on port 68,
+-# see https://dev.openwrt.org/ticket/4108
+-config rule
+-	option name		Allow-DHCP-Renew
+-	option src		wan
+-	option proto		udp
+-	option dest_port	68
+-	option target		ACCEPT
+-	option family		ipv4
+-
+-# Allow IPv4 ping
+-config rule
+-	option name		Allow-Ping
+-	option src		wan
+-	option proto		icmp
+-	option icmp_type	echo-request
+-	option family		ipv4
+-	option target		ACCEPT
+-
+-config rule
+-	option name		Allow-IGMP
+-	option src		wan
+-	option proto		igmp
+-	option family		ipv4
+-	option target		ACCEPT
+-
+-# Allow DHCPv6 replies
+-# see https://github.com/openwrt/openwrt/issues/5066
+-config rule
+-	option name		Allow-DHCPv6
+-	option src		wan
+-	option proto		udp
+-	option dest_port	546
+-	option family		ipv6
+-	option target		ACCEPT
+-
+-config rule
+-	option name		Allow-MLD
+-	option src		wan
+-	option proto		icmp
+-	option src_ip		fe80::/10
+-	list icmp_type		'130/0'
+-	list icmp_type		'131/0'
+-	list icmp_type		'132/0'
+-	list icmp_type		'143/0'
+-	option family		ipv6
+-	option target		ACCEPT
+-
+-# Allow essential incoming IPv6 ICMP traffic
+-config rule
+-	option name		Allow-ICMPv6-Input
+-	option src		wan
+-	option proto	icmp
+-	list icmp_type		echo-request
+-	list icmp_type		echo-reply
+-	list icmp_type		destination-unreachable
+-	list icmp_type		packet-too-big
+-	list icmp_type		time-exceeded
+-	list icmp_type		bad-header
+-	list icmp_type		unknown-header-type
+-	list icmp_type		router-solicitation
+-	list icmp_type		neighbour-solicitation
+-	list icmp_type		router-advertisement
+-	list icmp_type		neighbour-advertisement
+-	option limit		1000/sec
+-	option family		ipv6
+-	option target		ACCEPT
+-
+-# Allow essential forwarded IPv6 ICMP traffic
+-config rule
+-	option name		Allow-ICMPv6-Forward
+-	option src		wan
+-	option dest		*
+-	option proto		icmp
+-	list icmp_type		echo-request
+-	list icmp_type		echo-reply
+-	list icmp_type		destination-unreachable
+-	list icmp_type		packet-too-big
+-	list icmp_type		time-exceeded
+-	list icmp_type		bad-header
+-	list icmp_type		unknown-header-type
+-	option limit		1000/sec
+-	option family		ipv6
+-	option target		ACCEPT
+-
+-config rule
+-	option name		Allow-IPSec-ESP
+-	option src		wan
+-	option dest		lan
+-	option proto		esp
+-	option target		ACCEPT
+-
+-config rule
+-	option name		Allow-ISAKMP
+-	option src		wan
+-	option dest		lan
+-	option dest_port	500
+-	option proto		udp
+-	option target		ACCEPT
+-
+-
+-### EXAMPLE CONFIG SECTIONS
+-# do not allow a specific ip to access wan
+-#config rule
+-#	option src		lan
+-#	option src_ip	192.168.45.2
+-#	option dest		wan
+-#	option proto	tcp
+-#	option target	REJECT
+-
+-# block a specific mac on wan
+-#config rule
+-#	option dest		wan
+-#	option src_mac	00:11:22:33:44:66
+-#	option target	REJECT
+-
+-# block incoming ICMP traffic on a zone
+-#config rule
+-#	option src		lan
+-#	option proto	ICMP
+-#	option target	DROP
+-
+-# port redirect port coming in on wan to lan
+-#config redirect
+-#	option src			wan
+-#	option src_dport	80
+-#	option dest			lan
+-#	option dest_ip		192.168.16.235
+-#	option dest_port	80
+-#	option proto		tcp
+-
+-# port redirect of remapped ssh port (22001) on wan
+-#config redirect
+-#	option src		wan
+-#	option src_dport	22001
+-#	option dest		lan
+-#	option dest_port	22
+-#	option proto		tcp
+-
+-### FULL CONFIG SECTIONS
+-#config rule
+-#	option src		lan
+-#	option src_ip	192.168.45.2
+-#	option src_mac	00:11:22:33:44:55
+-#	option src_port	80
+-#	option dest		wan
+-#	option dest_ip	194.25.2.129
+-#	option dest_port	120
+-#	option proto	tcp
+-#	option target	REJECT
+-
+-#config redirect
+-#	option src		lan
+-#	option src_ip	192.168.45.2
+-#	option src_mac	00:11:22:33:44:55
+-#	option src_port		1024
+-#	option src_dport	80
+-#	option dest_ip	194.25.2.129
+-#	option dest_port	120
+-#	option proto	tcp
++config defaults
++	option synflood_protect '1'
++	option input 'DROP'
++	option output 'ACCEPT'
++	option forward 'DROP'
++	option fullcone '1'
++ 
++config zone
++	option name 'lan'
++	option input 'ACCEPT'
++	option output 'ACCEPT'
++	option forward 'ACCEPT'
++	list network 'lan'
++ 
++config zone
++	option name 'wan'
++	option input 'DROP'
++	option output 'ACCEPT'
++	option forward 'DROP'
++	option fullcone4 '1'
++	option fullcone6 '1'
++	option masq '1'
++	option mtu_fix '1'
++	list network 'wan'
++ 
++config forwarding
++	option src 'lan'
++	option dest 'wan'
++ 
++config rule
++	option name 'Allow-DHCPv6'
++	option family 'ipv6'
++	list proto 'udp'
++	option src 'wan'
++	list src_ip 'fc00::/6'
++	list dest_ip 'fc00::/6'
++	option dest_port '546'
++	option target 'ACCEPT'
++
++config rule
++	option name 'Allow-MLD'
++	option family 'ipv6'
++	list proto 'icmp'
++	option src 'wan'
++	list src_ip 'fe80::/10'
++	option target 'ACCEPT'
++ 
++	option path '/etc/firewall.user'
+
+--- /dev/null
++++ b/root/usr/share/firewall4/templates/zone-fullcone.uc
+@@ -0,0 +1,4 @@
++{# /usr/share/firewall4/templates/zone-fullcone.uc #}
++		meta nfproto {{ fw4.nfproto(family) }} fullcone comment "!fw4: Handle {{
++		zone.name
++}} {{ fw4.nfproto(family, true) }} fullcone NAT {{ direction }} traffic"
+--- a/root/usr/share/ucode/fw4.uc
++++ b/root/usr/share/ucode/fw4.uc
+@@ -1,3 +1,5 @@
++// /usr/share/ucode/fw4.uc
++
+ const fs = require("fs");
+ const uci = require("uci");
+ const ubus = require("ubus");
+@@ -428,6 +430,25 @@ function nft_try_hw_offload(devices) {
+ 	return (rc == 0);
+ }
+ 
++function nft_try_fullcone() {
++	let nft_test =
++		'add table inet fw4-fullcone-test; ' +
++		'add chain inet fw4-fullcone-test dstnat { ' +
++			'type nat hook prerouting priority -100; policy accept; ' +
++			'fullcone; ' +
++		'}; ' +
++		'add chain inet fw4-fullcone-test srcnat { ' +
++			'type nat hook postrouting priority -100; policy accept; ' +
++			'fullcone; ' +
++		'}; ';
++	let cmd = sprintf("/usr/sbin/nft -c '%s' 2>/dev/null", replace(nft_test, "'", "'\\''"));
++	let ok = system(cmd) == 0;
++	if (!ok) {
++		warn("nft_try_fullcone: cmd "+ cmd + "\n");
++	}
++	return ok;
++}
++
+ 
+ return {
+ 	read_kernel_version: function() {
+@@ -778,6 +799,18 @@ return {
+ 			warn(`[!] ${msg}\n`);
+ 	},
+ 
++	myinfo: function(fmt, ...args) {
++		if (getenv("QUIET"))
++			return;
++
++		let msg = sprintf(fmt, ...args);
++
++		if (getenv("TTY"))
++			warn(`\033[32m${msg}\033[m\n`);
++		else
++			warn(`[I] ${msg}\n`);
++	},
++
+ 	get: function(sid, opt) {
+ 		return this.cursor.get("firewall", sid, opt);
+ 	},
+@@ -959,6 +992,21 @@ return {
+ 		}
+ 	},
+ 
++	myinfo_section: function(s, msg) {
++		if (s[".name"]) {
++			if (s.name)
++				this.myinfo("Section %s (%s) %s", this.section_id(s[".name"]), s.name, msg);
++			else
++				this.myinfo("Section %s %s", this.section_id(s[".name"]), msg);
++		}
++		else {
++			if (s.name)
++				this.myinfo("ubus %s (%s) %s", s.type || "rule", s.name, msg);
++			else
++				this.myinfo("ubus %s %s", s.type || "rule", msg);
++		}
++	},
++
+ 	parse_policy: function(val) {
+ 		return this.parse_enum(val, [
+ 			"accept",
+@@ -1398,6 +1446,7 @@ return {
+ 			"dnat",
+ 			"snat",
+ 			"masquerade",
++			"fullcone",
+ 			"accept",
+ 			"reject",
+ 			"drop"
+@@ -1865,6 +1914,7 @@ return {
+ 		}
+ 
+ 		let defs = this.parse_options(data, {
++			fullcone: [ "bool", "0" ],
+ 			input: [ "policy", "drop" ],
+ 			output: [ "policy", "drop" ],
+ 			forward: [ "policy", "drop" ],
+@@ -1899,6 +1949,11 @@ return {
+ 
+ 		delete defs.syn_flood;
+ 
++		if (!nft_try_fullcone()) {
++			delete defs.fullcone;
++			warn("nft_try_fullcone failed, disable fullcone globally\n");
++		}
++
+ 		this.state.defaults = defs;
+ 	},
+ 
+@@ -1923,6 +1978,8 @@ return {
+ 			masq_dest: [ "network", null, PARSE_LIST ],
+ 
+ 			masq6: [ "bool" ],
++			fullcone4: [ "bool", "0" ],
++			fullcone6: [ "bool", "0" ],
+ 
+ 			extra: [ "string", null, UNSUPPORTED ],
+ 			extra_src: [ "string", null, UNSUPPORTED ],
+@@ -1955,6 +2012,18 @@ return {
+ 			}
+ 		}
+ 
++		if (this.state.defaults && !this.state.defaults.fullcone) {
++			this.warn_section(data, "fullcone in defaults not enabled, ignore zone fullcone settings");
++			zone.fullcone4 = false;
++			zone.fullcone6 = false;
++		}
++		if (zone.fullcone4) {
++			this.myinfo_section(data, "IPv4 fullcone enabled for zone '" + zone.name + "'");
++		}
++		if (zone.fullcone6) {
++			this.myinfo_section(data, "IPv6 fullcone enabled for zone '" + zone.name + "'");
++		}
++
+ 		if (zone.mtu_fix && this.kernel < 0x040a0000) {
+ 			this.warn_section(data, "option 'mtu_fix' requires kernel 4.10 or later");
+ 			return;
+@@ -2124,10 +2193,15 @@ return {
+ 		zone.related_subnets = related_subnets;
+ 		zone.related_physdevs = related_physdevs;
+ 
++		if (zone.fullcone4 || zone.fullcone6) {
++			zone.dflags.snat = true;
++			zone.dflags.dnat = true;
++		}
++
+ 		if (zone.masq || zone.masq6)
+ 			zone.dflags.snat = true;
+ 
+-		if ((zone.auto_helper && !(zone.masq || zone.masq6)) || length(zone.helper)) {
++		if ((zone.auto_helper && !(zone.masq || zone.masq6 || zone.fullcone4 || zone.fullcone6)) || length(zone.helper)) {
+ 			zone.dflags.helper = true;
+ 
+ 			for (let helper in (length(zone.helper) ? zone.helper : this.state.helpers)) {
+--- a/root/usr/share/firewall4/templates/ruleset.uc
++++ b/root/usr/share/firewall4/templates/ruleset.uc
+@@ -316,6 +316,12 @@ table inet fw4 {
+ {%   for (let redirect in fw4.redirects(`dstnat_${zone.name}`)): %}
+ 		{%+ include("redirect.uc", { fw4, redirect }) %}
+ {%   endfor %}
++{%   if (zone.fullcone4): %}
++		{%+ include("zone-fullcone.uc", { fw4, zone, family: 4, direction: "dstnat" }) %}
++{%   endif %}
++{%   if (zone.fullcone6): %}
++		{%+ include("zone-fullcone.uc", { fw4, zone, family: 6, direction: "dstnat" }) %}
++{%   endif %}
+ {%   fw4.includes('chain-append', `dstnat_${zone.name}`) %}
+ 	}
+ 
+@@ -326,20 +332,26 @@ table inet fw4 {
+ {%   for (let redirect in fw4.redirects(`srcnat_${zone.name}`)): %}
+ 		{%+ include("redirect.uc", { fw4, redirect }) %}
+ {%   endfor %}
+-{%   if (zone.masq): %}
++{%   if (zone.masq && !zone.fullcone4): %}
+ {%    for (let saddrs in zone.masq4_src_subnets): %}
+ {%     for (let daddrs in zone.masq4_dest_subnets): %}
+ 		{%+ include("zone-masq.uc", { fw4, zone, family: 4, saddrs, daddrs }) %}
+ {%     endfor %}
+ {%    endfor %}
+ {%   endif %}
+-{%   if (zone.masq6): %}
++{%   if (zone.masq6 && !zone.fullcone6): %}
+ {%    for (let saddrs in zone.masq6_src_subnets): %}
+ {%     for (let daddrs in zone.masq6_dest_subnets): %}
+ 		{%+ include("zone-masq.uc", { fw4, zone, family: 6, saddrs, daddrs }) %}
+ {%     endfor %}
+ {%    endfor %}
+ {%   endif %}
++{%   if (zone.fullcone4): %}
++		{%+ include("zone-fullcone.uc", { fw4, zone, family: 4, direction: "srcnat" }) %}
++{%   endif %}
++{%   if (zone.fullcone6): %}
++		{%+ include("zone-fullcone.uc", { fw4, zone, family: 6, direction: "srcnat" }) %}
++{%   endif %}
+ {%   fw4.includes('chain-append', `srcnat_${zone.name}`) %}
+ 	}

--- /dev/null
+++ b/package/network/utils/nftables/patches/999-01-nftables-add-fullcone-expression-support.patch
@@ -0,0 +1,209 @@
+From b6e3ad4c0bb845a05d73ef1be46ffb73517d1565 Mon Sep 17 00:00:00 2001
+From: Syrone Wong <wong.syrone@gmail.com>
+Date: Sat, 9 Apr 2022 00:38:51 +0800
+Subject: [PATCH] nftables: add fullcone expression support
+
+Signed-off-by: Syrone Wong <wong.syrone@gmail.com>
+---
+ include/linux/netfilter/nf_tables.h | 16 ++++++++++
+ include/statement.h                 |  1 +
+ src/netlink_delinearize.c           | 48 +++++++++++++++++++++++++++++
+ src/netlink_linearize.c             |  7 +++++
+ src/parser_bison.y                  | 28 +++++++++++++++--
+ src/scanner.l                       |  1 +
+ src/statement.c                     |  1 +
+ 7 files changed, 100 insertions(+), 2 deletions(-)
+
+--- a/include/linux/netfilter/nf_tables.h
++++ b/include/linux/netfilter/nf_tables.h
+@@ -1410,6 +1410,22 @@ enum nft_masq_attributes {
+ #define NFTA_MASQ_MAX		(__NFTA_MASQ_MAX - 1)
+ 
+ /**
++ * enum nft_fullcone_attributes - nf_tables fullcone expression attributes
++ *
++ * @NFTA_FULLCONE_FLAGS: NAT flags (see NF_NAT_RANGE_* in linux/netfilter/nf_nat.h) (NLA_U32)
++ * @NFTA_FULLCONE_REG_PROTO_MIN: source register of proto range start (NLA_U32: nft_registers)
++ * @NFTA_FULLCONE_REG_PROTO_MAX: source register of proto range end (NLA_U32: nft_registers)
++ */
++enum nft_fullcone_attributes {
++	NFTA_FULLCONE_UNSPEC,
++	NFTA_FULLCONE_FLAGS,
++	NFTA_FULLCONE_REG_PROTO_MIN,
++	NFTA_FULLCONE_REG_PROTO_MAX,
++	__NFTA_FULLCONE_MAX
++};
++#define NFTA_FULLCONE_MAX		(__NFTA_FULLCONE_MAX - 1)
++
++/**
+  * enum nft_redir_attributes - nf_tables redirect expression netlink attributes
+  *
+  * @NFTA_REDIR_REG_PROTO_MIN: source register of proto range start (NLA_U32: nft_registers)
+--- a/include/statement.h
++++ b/include/statement.h
+@@ -122,6 +122,7 @@ enum nft_nat_etypes {
+ 	__NFT_NAT_SNAT = NFT_NAT_SNAT,
+ 	__NFT_NAT_DNAT = NFT_NAT_DNAT,
+ 	NFT_NAT_MASQ,
++	NFT_NAT_FULLCONE,
+ 	NFT_NAT_REDIR,
+ };
+ 
+--- a/src/netlink_delinearize.c
++++ b/src/netlink_delinearize.c
+@@ -1370,6 +1370,53 @@ out_err:
+ 	stmt_free(stmt);
+ }
+ 
++static void netlink_parse_fullcone(struct netlink_parse_ctx *ctx,
++			       const struct location *loc,
++			       const struct nftnl_expr *nle)
++{
++	enum nft_registers reg1, reg2;
++	struct expr *proto;
++	struct stmt *stmt;
++	uint32_t flags = 0;
++
++	if (nftnl_expr_is_set(nle, NFTNL_EXPR_FULLCONE_FLAGS))
++		flags = nftnl_expr_get_u32(nle, NFTNL_EXPR_FULLCONE_FLAGS);
++
++	stmt = nat_stmt_alloc(loc, NFT_NAT_FULLCONE);
++	stmt->nat.flags = flags;
++
++	reg1 = netlink_parse_register(nle, NFTNL_EXPR_FULLCONE_REG_PROTO_MIN);
++	if (reg1) {
++		proto = netlink_get_register(ctx, loc, reg1);
++		if (proto == NULL) {
++			netlink_error(ctx, loc,
++				      "fullcone statement has no proto expression");
++			goto out_err;
++		}
++		expr_set_type(proto, &inet_service_type, BYTEORDER_BIG_ENDIAN);
++		stmt->nat.proto = proto;
++	}
++
++	reg2 = netlink_parse_register(nle, NFTNL_EXPR_FULLCONE_REG_PROTO_MAX);
++	if (reg2 && reg2 != reg1) {
++		proto = netlink_get_register(ctx, loc, reg2);
++		if (proto == NULL) {
++			netlink_error(ctx, loc,
++				      "fullcone statement has no proto expression");
++			goto out_err;
++		}
++		expr_set_type(proto, &inet_service_type, BYTEORDER_BIG_ENDIAN);
++		if (stmt->nat.proto != NULL)
++			proto = range_expr_alloc(loc, stmt->nat.proto, proto);
++		stmt->nat.proto = proto;
++	}
++
++	ctx->stmt = stmt;
++	return;
++out_err:
++	stmt_free(stmt);
++}
++
+ static void netlink_parse_redir(struct netlink_parse_ctx *ctx,
+ 				const struct location *loc,
+ 				const struct nftnl_expr *nle)
+@@ -1788,6 +1835,7 @@ static const struct expr_handler netlink
+ 	{ .name = "tproxy",	.parse = netlink_parse_tproxy },
+ 	{ .name = "notrack",	.parse = netlink_parse_notrack },
+ 	{ .name = "masq",	.parse = netlink_parse_masq },
++	{ .name = "fullcone",	.parse = netlink_parse_fullcone },
+ 	{ .name = "redir",	.parse = netlink_parse_redir },
+ 	{ .name = "dup",	.parse = netlink_parse_dup },
+ 	{ .name = "queue",	.parse = netlink_parse_queue },
+--- a/src/netlink_linearize.c
++++ b/src/netlink_linearize.c
+@@ -1140,6 +1140,13 @@ static void netlink_gen_nat_stmt(struct
+ 		nftnl_reg_pmin = NFTNL_EXPR_MASQ_REG_PROTO_MIN;
+ 		nftnl_reg_pmax = NFTNL_EXPR_MASQ_REG_PROTO_MAX;
+ 		break;
++	case NFT_NAT_FULLCONE:
++		nle = alloc_nft_expr("fullcone");
++
++		nftnl_flag_attr = NFTNL_EXPR_FULLCONE_FLAGS;
++		nftnl_reg_pmin = NFTNL_EXPR_FULLCONE_REG_PROTO_MIN;
++		nftnl_reg_pmax = NFTNL_EXPR_FULLCONE_REG_PROTO_MAX;
++		break;
+ 	case NFT_NAT_REDIR:
+ 		nle = alloc_nft_expr("redir");
+ 
+--- a/src/parser_bison.y
++++ b/src/parser_bison.y
+@@ -571,6 +571,7 @@ int nft_lex(void *, void *, void *);
+ %token SNAT			"snat"
+ %token DNAT			"dnat"
+ %token MASQUERADE		"masquerade"
++%token FULLCONE		"fullcone"
+ %token REDIRECT			"redirect"
+ %token RANDOM			"random"
+ %token FULLY_RANDOM		"fully-random"
+@@ -703,8 +704,8 @@ int nft_lex(void *, void *, void *);
+ %type <val>			limit_burst_pkts limit_burst_bytes limit_mode limit_bytes time_unit quota_mode
+ %type <stmt>			reject_stmt reject_stmt_alloc
+ %destructor { stmt_free($$); }	reject_stmt reject_stmt_alloc
+-%type <stmt>			nat_stmt nat_stmt_alloc masq_stmt masq_stmt_alloc redir_stmt redir_stmt_alloc
+-%destructor { stmt_free($$); }	nat_stmt nat_stmt_alloc masq_stmt masq_stmt_alloc redir_stmt redir_stmt_alloc
++%type <stmt>			nat_stmt nat_stmt_alloc masq_stmt masq_stmt_alloc fullcone_stmt fullcone_stmt_alloc redir_stmt redir_stmt_alloc
++%destructor { stmt_free($$); }	nat_stmt nat_stmt_alloc masq_stmt masq_stmt_alloc fullcone_stmt fullcone_stmt_alloc redir_stmt redir_stmt_alloc
+ %type <val>			nf_nat_flags nf_nat_flag offset_opt
+ %type <stmt>			tproxy_stmt
+ %destructor { stmt_free($$); }	tproxy_stmt
+@@ -2852,6 +2853,7 @@ stmt			:	verdict_stmt
+ 			|	queue_stmt
+ 			|	ct_stmt
+ 			|	masq_stmt	close_scope_nat
++			|	fullcone_stmt	close_scope_nat
+ 			|	redir_stmt	close_scope_nat
+ 			|	dup_stmt	close_scope_dup
+ 			|	fwd_stmt	close_scope_fwd
+@@ -3741,6 +3743,28 @@ masq_stmt_args		:	TO 	COLON	stmt_expr
+ 			{
+ 				$<stmt>0->nat.proto = $3;
+ 			}
++			|	TO 	COLON	stmt_expr	nf_nat_flags
++			{
++				$<stmt>0->nat.proto = $3;
++				$<stmt>0->nat.flags = $4;
++			}
++			|	nf_nat_flags
++			{
++				$<stmt>0->nat.flags = $1;
++			}
++			;
++
++fullcone_stmt		:	fullcone_stmt_alloc		fullcone_stmt_args
++			|	fullcone_stmt_alloc
++			;
++
++fullcone_stmt_alloc		:	FULLCONE	{ $$ = nat_stmt_alloc(&@$, NFT_NAT_FULLCONE); }
++			;
++
++fullcone_stmt_args		:	TO 	COLON	stmt_expr
++			{
++				$<stmt>0->nat.proto = $3;
++			}
+ 			|	TO 	COLON	stmt_expr	nf_nat_flags
+ 			{
+ 				$<stmt>0->nat.proto = $3;
+--- a/src/scanner.l
++++ b/src/scanner.l
+@@ -447,6 +447,7 @@ addrstring	({macaddr}|{ip4addr}|{ip6addr
+ "snat"		{ scanner_push_start_cond(yyscanner, SCANSTATE_STMT_NAT); return SNAT; }
+ "dnat"		{ scanner_push_start_cond(yyscanner, SCANSTATE_STMT_NAT); return DNAT; }
+ "masquerade"		{ scanner_push_start_cond(yyscanner, SCANSTATE_STMT_NAT); return MASQUERADE; }
++"fullcone"		{ scanner_push_start_cond(yyscanner, SCANSTATE_STMT_NAT); return FULLCONE; }
+ "redirect"		{ scanner_push_start_cond(yyscanner, SCANSTATE_STMT_NAT); return REDIRECT; }
+ "random"		{ return RANDOM; }
+ <SCANSTATE_STMT_NAT>{
+--- a/src/statement.c
++++ b/src/statement.c
+@@ -650,6 +650,7 @@ const char *nat_etype2str(enum nft_nat_e
+ 		[NFT_NAT_SNAT]	= "snat",
+ 		[NFT_NAT_DNAT]	= "dnat",
+ 		[NFT_NAT_MASQ]	= "masquerade",
++		[NFT_NAT_FULLCONE] = "fullcone",
+ 		[NFT_NAT_REDIR]	= "redirect",
+ 	};
+

--- a/package/libs/libnftnl/Makefile
+++ b/package/libs/libnftnl/Makefile
@@ -19,7 +19,7 @@
 PKG_MAINTAINER:=Steven Barth <steven@midlink.org>
 PKG_LICENSE:=GPL-2.0-or-later
 PKG_LICENSE_FILES:=COPYING
-
+PKG_FIXUP:=autoreconf
 PKG_INSTALL:=1
 PKG_BUILD_PARALLEL:=1
 PKG_BUILD_FLAGS:=lto

--- /dev/null
+++ b/package/libs/libnftnl/patches/999-01-libnftnl-add-fullcone-expression-support.patch
@@ -0,0 +1,254 @@
+From 6c39f04febd7cfdbd474233379416babcd0fc341 Mon Sep 17 00:00:00 2001
+From: Syrone Wong <wong.syrone@gmail.com>
+Date: Fri, 8 Apr 2022 23:52:11 +0800
+Subject: [PATCH] libnftnl: add fullcone expression support
+
+Signed-off-by: Syrone Wong <wong.syrone@gmail.com>
+---
+ include/libnftnl/expr.h             |   6 +
+ include/linux/netfilter/nf_tables.h |  16 +++
+ src/Makefile.am                     |   1 +
+ src/expr/fullcone.c                 | 167 ++++++++++++++++++++++++++++
+ src/expr_ops.c                      |   2 +
+ 5 files changed, 192 insertions(+)
+ create mode 100644 src/expr/fullcone.c
+
+--- a/include/libnftnl/expr.h
++++ b/include/libnftnl/expr.h
+@@ -245,6 +245,12 @@ enum {
+ };
+ 
+ enum {
++	NFTNL_EXPR_FULLCONE_FLAGS		= NFTNL_EXPR_BASE,
++	NFTNL_EXPR_FULLCONE_REG_PROTO_MIN,
++	NFTNL_EXPR_FULLCONE_REG_PROTO_MAX,
++};
++
++enum {
+ 	NFTNL_EXPR_REDIR_REG_PROTO_MIN	= NFTNL_EXPR_BASE,
+ 	NFTNL_EXPR_REDIR_REG_PROTO_MAX,
+ 	NFTNL_EXPR_REDIR_FLAGS,
+--- a/include/linux/netfilter/nf_tables.h
++++ b/include/linux/netfilter/nf_tables.h
+@@ -1434,6 +1434,22 @@ enum nft_masq_attributes {
+ #define NFTA_MASQ_MAX		(__NFTA_MASQ_MAX - 1)
+ 
+ /**
++ * enum nft_fullcone_attributes - nf_tables fullcone expression attributes
++ *
++ * @NFTA_FULLCONE_FLAGS: NAT flags (see NF_NAT_RANGE_* in linux/netfilter/nf_nat.h) (NLA_U32)
++ * @NFTA_FULLCONE_REG_PROTO_MIN: source register of proto range start (NLA_U32: nft_registers)
++ * @NFTA_FULLCONE_REG_PROTO_MAX: source register of proto range end (NLA_U32: nft_registers)
++ */
++enum nft_fullcone_attributes {
++	NFTA_FULLCONE_UNSPEC,
++	NFTA_FULLCONE_FLAGS,
++	NFTA_FULLCONE_REG_PROTO_MIN,
++	NFTA_FULLCONE_REG_PROTO_MAX,
++	__NFTA_FULLCONE_MAX
++};
++#define NFTA_FULLCONE_MAX		(__NFTA_FULLCONE_MAX - 1)
++
++/**
+  * enum nft_redir_attributes - nf_tables redirect expression netlink attributes
+  *
+  * @NFTA_REDIR_REG_PROTO_MIN: source register of proto range start (NLA_U32: nft_registers)
+--- a/src/Makefile.am
++++ b/src/Makefile.am
+@@ -54,6 +54,7 @@ libnftnl_la_SOURCES = utils.c		\
+ 		      expr/target.c	\
+ 		      expr/tunnel.c	\
+ 		      expr/masq.c	\
++		      expr/fullcone.c	\
+ 		      expr/redir.c	\
+ 		      expr/hash.c	\
+ 		      expr/socket.c	\
+--- /dev/null
++++ b/src/expr/fullcone.c
+@@ -0,0 +1,168 @@
++/*
++ * (C) 2022 wongsyrone
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published
++ * by the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ */
++
++#include <stdio.h>
++#include <stdint.h>
++#include <arpa/inet.h>
++#include <errno.h>
++#include <inttypes.h>
++
++#include <linux/netfilter/nf_tables.h>
++
++#include "internal.h"
++#include <libmnl/libmnl.h>
++#include <libnftnl/expr.h>
++#include <libnftnl/rule.h>
++
++struct nftnl_expr_fullcone {
++	uint32_t		flags;
++	enum nft_registers	sreg_proto_min;
++	enum nft_registers	sreg_proto_max;
++};
++
++static int
++nftnl_expr_fullcone_set(struct nftnl_expr *e, uint16_t type,
++		       const void *data, uint32_t data_len)
++{
++	struct nftnl_expr_fullcone *fullcone = nftnl_expr_data(e);
++
++	switch (type) {
++	case NFTNL_EXPR_FULLCONE_FLAGS:
++		memcpy(&fullcone->flags, data, sizeof(fullcone->flags));
++		break;
++	case NFTNL_EXPR_FULLCONE_REG_PROTO_MIN:
++		memcpy(&fullcone->sreg_proto_min, data, sizeof(fullcone->sreg_proto_min));
++		break;
++	case NFTNL_EXPR_FULLCONE_REG_PROTO_MAX:
++		memcpy(&fullcone->sreg_proto_max, data, sizeof(fullcone->sreg_proto_max));
++		break;
++	default:
++		return -1;
++	}
++	return 0;
++}
++
++static const void *
++nftnl_expr_fullcone_get(const struct nftnl_expr *e, uint16_t type,
++		       uint32_t *data_len)
++{
++	struct nftnl_expr_fullcone *fullcone = nftnl_expr_data(e);
++
++	switch (type) {
++	case NFTNL_EXPR_FULLCONE_FLAGS:
++		*data_len = sizeof(fullcone->flags);
++		return &fullcone->flags;
++	case NFTNL_EXPR_FULLCONE_REG_PROTO_MIN:
++		*data_len = sizeof(fullcone->sreg_proto_min);
++		return &fullcone->sreg_proto_min;
++	case NFTNL_EXPR_FULLCONE_REG_PROTO_MAX:
++		*data_len = sizeof(fullcone->sreg_proto_max);
++		return &fullcone->sreg_proto_max;
++	}
++	return NULL;
++}
++
++static int nftnl_expr_fullcone_cb(const struct nlattr *attr, void *data)
++{
++	const struct nlattr **tb = data;
++	int type = mnl_attr_get_type(attr);
++
++	if (mnl_attr_type_valid(attr, NFTA_FULLCONE_MAX) < 0)
++		return MNL_CB_OK;
++
++	switch (type) {
++	case NFTA_FULLCONE_REG_PROTO_MIN:
++	case NFTA_FULLCONE_REG_PROTO_MAX:
++	case NFTA_FULLCONE_FLAGS:
++		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
++			abi_breakage();
++		break;
++	}
++
++	tb[type] = attr;
++	return MNL_CB_OK;
++}
++
++static void
++nftnl_expr_fullcone_build(struct nlmsghdr *nlh, const struct nftnl_expr *e)
++{
++	struct nftnl_expr_fullcone *fullcone = nftnl_expr_data(e);
++
++	if (e->flags & (1 << NFTNL_EXPR_FULLCONE_FLAGS))
++		mnl_attr_put_u32(nlh, NFTA_FULLCONE_FLAGS, htobe32(fullcone->flags));
++	if (e->flags & (1 << NFTNL_EXPR_FULLCONE_REG_PROTO_MIN))
++		mnl_attr_put_u32(nlh, NFTA_FULLCONE_REG_PROTO_MIN,
++				 htobe32(fullcone->sreg_proto_min));
++	if (e->flags & (1 << NFTNL_EXPR_FULLCONE_REG_PROTO_MAX))
++		mnl_attr_put_u32(nlh, NFTA_FULLCONE_REG_PROTO_MAX,
++				 htobe32(fullcone->sreg_proto_max));
++}
++
++static int
++nftnl_expr_fullcone_parse(struct nftnl_expr *e, struct nlattr *attr)
++{
++	struct nftnl_expr_fullcone *fullcone = nftnl_expr_data(e);
++	struct nlattr *tb[NFTA_FULLCONE_MAX+1] = {};
++
++	if (mnl_attr_parse_nested(attr, nftnl_expr_fullcone_cb, tb) < 0)
++		return -1;
++
++	if (tb[NFTA_FULLCONE_FLAGS]) {
++		fullcone->flags = be32toh(mnl_attr_get_u32(tb[NFTA_FULLCONE_FLAGS]));
++		e->flags |= (1 << NFTNL_EXPR_FULLCONE_FLAGS);
++        }
++	if (tb[NFTA_FULLCONE_REG_PROTO_MIN]) {
++		fullcone->sreg_proto_min =
++			be32toh(mnl_attr_get_u32(tb[NFTA_FULLCONE_REG_PROTO_MIN]));
++		e->flags |= (1 << NFTNL_EXPR_FULLCONE_REG_PROTO_MIN);
++	}
++	if (tb[NFTA_FULLCONE_REG_PROTO_MAX]) {
++		fullcone->sreg_proto_max =
++			be32toh(mnl_attr_get_u32(tb[NFTA_FULLCONE_REG_PROTO_MAX]));
++		e->flags |= (1 << NFTNL_EXPR_FULLCONE_REG_PROTO_MAX);
++	}
++
++	return 0;
++}
++
++static int nftnl_expr_fullcone_snprintf(char *buf, size_t remain,
++				    uint32_t flags, const struct nftnl_expr *e)
++{
++	struct nftnl_expr_fullcone *fullcone = nftnl_expr_data(e);
++	int offset = 0, ret = 0;
++
++	if (e->flags & (1 << NFTNL_EXPR_FULLCONE_REG_PROTO_MIN)) {
++		ret = snprintf(buf + offset, remain, "proto_min reg %u ",
++			       fullcone->sreg_proto_min);
++		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
++	}
++	if (e->flags & (1 << NFTNL_EXPR_FULLCONE_REG_PROTO_MAX)) {
++		ret = snprintf(buf + offset, remain, "proto_max reg %u ",
++			       fullcone->sreg_proto_max);
++		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
++	}
++	if (e->flags & (1 << NFTNL_EXPR_FULLCONE_FLAGS)) {
++		ret = snprintf(buf + offset, remain, "flags 0x%x ", fullcone->flags);
++		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
++	}
++
++	return offset;
++}
++
++struct expr_ops expr_ops_fullcone = {
++	.name		= "fullcone",
++	.alloc_len	= sizeof(struct nftnl_expr_fullcone),
++	.max_attr	= NFTA_FULLCONE_MAX,
++	.set		= nftnl_expr_fullcone_set,
++	.get		= nftnl_expr_fullcone_get,
++	.parse		= nftnl_expr_fullcone_parse,
++	.build		= nftnl_expr_fullcone_build,
++	.output		= nftnl_expr_fullcone_snprintf,
++};
++
+--- a/src/expr_ops.c
++++ b/src/expr_ops.c
+@@ -19,6 +19,7 @@ extern struct expr_ops expr_ops_limit;
+ extern struct expr_ops expr_ops_log;
+ extern struct expr_ops expr_ops_lookup;
+ extern struct expr_ops expr_ops_masq;
++extern struct expr_ops expr_ops_fullcone;
+ extern struct expr_ops expr_ops_match;
+ extern struct expr_ops expr_ops_meta;
+ extern struct expr_ops expr_ops_ng;
+@@ -63,6 +64,7 @@ static struct expr_ops *expr_ops[] = {
+ 	&expr_ops_log,
+ 	&expr_ops_lookup,
+ 	&expr_ops_masq,
++	&expr_ops_fullcone,
+ 	&expr_ops_match,
+ 	&expr_ops_meta,
+ 	&expr_ops_ng,
